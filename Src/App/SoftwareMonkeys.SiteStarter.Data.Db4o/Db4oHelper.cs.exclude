using System;
using System.IO;
using System.ComponentModel;
using System.Collections;
using System.Collections.Generic;
using Db4objects.Db4o;
using Db4objects.Db4o.Query;
using Db4objects.Db4o.Ext;
using System.Reflection;
using SoftwareMonkeys.WorkHub;
using SoftwareMonkeys.WorkHub.Entities;

namespace SoftwareMonkeys.WorkHub.Data
{
    /// <summary>
    /// Assists in interaction with the db4o database.
    /// </summary>
	public static class Db4oHelper
    {
        #region IObjectContainer
 /*       static private IObjectContainer db;
        /// <summary>
		/// Gets/sets the database IObjectContainer.
		/// </summary>
		static public IObjectContainer DB
		{
			get
			{	
				if (db == null)
					LoadDB();
                return db;
			}
			set
			{
                db = value;
			}
        }*/

        // TODO: Remove
 /*       /// <summary>
        /// Loads the data from the .yap file.
        /// </summary>
        static public void LoadDB()
        {
            if (!Config.IsSetUp)
                throw new InvalidOperationException("The application config file is not present. Run the setup process and try again.");
            // Add messages to the trace
            System.Diagnostics.Trace.WriteLine("===== DB4O =====");
            System.Diagnostics.Trace.WriteLine(Config.Current.MapPath(Config.Current.DatabasePath), "Loading DB");

            if (!Directory.Exists(Path.GetDirectoryName(Config.Current.MapPath(Config.Current.DatabasePath))))
                Directory.CreateDirectory(Path.GetDirectoryName(Config.Current.MapPath(Config.Current.DatabasePath)));

            Db4o.Configure().GenerateUUIDs(Int16.MaxValue);

            DataStore = Db4o.OpenFile(Config.Current.MapPath(Config.Current.DatabasePath));
        }*/

        /// <summary>
        /// Loads the data from the .yap file.
        /// </summary>
        static public IObjectServer LoadDataServer(string dataStoreName)
        {
            throw new NotImplementedException();
            // TODO: Uncomment and update
      /*      if (!Config.IsSetUp)
                throw new InvalidOperationException("The application config file is not present. Run the setup process and try again.");
            // Add messages to the trace
  //          System.Diagnostics.Trace.WriteLine("===== DB4O =====");
  //          System.Diagnostics.Trace.WriteLine(Config.Current.MapPath(Config.Current.DatabasePath), "Loading data store: " + dataStoreName);

  //          if (!Directory.Exists(Path.GetDirectoryName(Config.Current.MapPath(Config.Current.DatabasePath))))
   //             Directory.CreateDirectory(Path.GetDirectoryName(Config.Current.MapPath(Config.Current.DatabasePath)));

   //         return Config.Current.GetDataServer(dataStoreName).OpenClient();

            Db4oFactory.Configure().AllowVersionUpdates(true);
            Db4oFactory.Configure().ActivationDepth(2);

            return Db4oFactory.OpenServer(Config.Application.PhysicalPath + @"\" + dataStoreName + ".yap", 0);*/
        }

        // TODO: Remove
      /*  /// <summary>
        /// Closes the data and commits it to the .yap file.
        /// </summary>
        static public void CloseDB()
        {
            if (DB != null)
            {
                DB.Close();
            }
            DB = null;
        }*/

        /// <summary>
        /// Closes the specified data store.
        /// </summary>
        static public void CloseDataStore(Type type)
        {
            CloseDataStore(DataAccess.Data.Stores[type].Name);
        }

        /// <summary>
        /// Closes the specified data store.
        /// </summary>
        static public void CloseDataStore(IObjectContainer dataStore)
        {
            dataStore.Close();
        }


        /// <summary>
        /// Closes the specified data store.
        /// </summary>
        static public void CloseDataStore(string dataStoreName)
        {
            System.Diagnostics.Trace.WriteLine(dataStoreName, "Db4oHelper.CloseDataStore");
            throw new NotImplementedException();
            // TODO: Uncommend and update
            /*IObjectContainer store = GetDataStore(dataStoreName);
            if (store != null)
            {
                store.Close();
                Config.Current.RemoveDataStore(dataStoreName);
            }*/
        }

        /// <summary>
        /// Closes all data stores.
        /// </summary>
        static public void CloseDataServers()
        {
            throw new NotImplementedException();
            // TODO: Uncommend and update
            //Config.Current.RemoveDataServers();
        }
        #endregion

        #region Data functions
        /// <summary>
        /// Retrieves the UUID of the provided object.
        /// </summary>
        /// <param name="dataStore">The data store containing the object to get the ID for.</param>
        /// <param name="obj">The object to get the ID of.</param>
        /// <returns>The UUID of the provided object.</returns>
        static public string GetID(IObjectContainer dataStore, object obj)
        {
            return dataStore.Ext().GetObjectInfo(obj).GetUUID().ToString();
        }

        /// <summary>
		/// Retrieves all the objects from the provided IObjectSet.
		/// </summary>
        /// <param name="objectSet">The type of objects being retrieved.</param>
		/// <param name="type">The IObjectSet containing the objects to retrieve.</param>
		/// <returns>An array of the retrieved objects.</returns>
		static public object[] GetObjects(Type type, IObjectSet objectSet)
		{
            if (!objectSet.HasNext())
				return null;

			ArrayList list = new ArrayList();
            while (objectSet.HasNext())
                list.Add(objectSet.Next());

			return (object[])list.ToArray(type);
		}

        /// <summary>
        /// Retrieves all the objects of the specified type matching the parameter.
        /// </summary>
        /// <param name="type">The type of objects to retrieve.</param>
        /// <param name="parameterName">The name of the parameter to match.</param>
        /// <param name="parameterValue">The value of the parameter to match.</param>
        /// <returns>An array of the retrieved objects.</returns>
        static public object[] GetObjects(Type type, string parameterName, object parameterValue)
        {
            IObjectContainer dataStore = GetDataStore(type, true);

            try
            {
                return GetObjects(dataStore, type, parameterName, parameterValue);
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }


        /// <summary>
        /// Retrieves all the objects of the specified type matching the parameter.
        /// </summary>
        /// <param name="dataStore">The data store to get the objects from.</param>
        /// <param name="type">The type of objects to retrieve.</param>
        /// <param name="parameterName">The name of the parameter to match.</param>
        /// <param name="parameterValue">The value of the parameter to match.</param>
        /// <returns>An array of the retrieved objects.</returns>
        static public object[] GetObjects(IObjectContainer dataStore, Type type, string parameterName, object parameterValue)
        {
            IQuery query = dataStore.Query();
            query.Constrain(type);
            query.Descend(parameterName).Constrain(parameterValue);

            IObjectSet os = query.Execute();
            if (!os.HasNext())
                return null;

            ArrayList list = new ArrayList();
            while (os.HasNext())
                list.Add(os.Next());

            return (object[])list.ToArray(typeof(object));
        }

        /// <summary>
        /// Retrieves all the objects of the specified type.
        /// </summary>
        /// <param name="type">The type of objects to retrieve.</param>
        /// <returns>An array of the retrieved objects.</returns>
        static public object[] GetObjects(Type type)
        {
            IObjectContainer dataStore = GetDataStore(type, true);

            IQuery query = dataStore.Query();
            query.Constrain(type);

            IObjectSet os = query.Execute();
            if (!os.HasNext())
                return null;

            ArrayList list = new ArrayList();
            while (os.HasNext())
                list.Add(os.Next());

            return (object[])list.ToArray(type);
        }

        /// <summary>
        /// Retrieves all the objects of the specified type.
        /// </summary>
        /// <param name="dataStore">The data store to get all the objects from.</param>
        /// <returns>An array of the retrieved objects.</returns>
        static public object[] GetAllObjects(IObjectContainer dataStore)
        {
            IQuery query = dataStore.Query();
            query.Constrain(typeof(object));


            IObjectSet os = query.Execute();
            if (!os.HasNext())
                return null;

            ArrayList list = new ArrayList();
            while (os.HasNext())
                list.Add(os.Next());

            return (object[])list.ToArray(typeof(object));
        }

        /*/// <summary>
        /// Retrieves the objects of the specified type matching the parameters.
        /// </summary>
        /// <param name="type">The type of objects to retrieve.</param>
        /// <param name="parameters">The parameters to match on the objects.</param>
        /// <returns>An array or the retrieved objects.</returns>
        static public object[] GetObjects(Type type, Hashtable parameters)
		{
			IQuery query = DB.Query();
			query.Constrain(type);
			foreach (string key in parameters.Keys)
			{
				Constraint constraint = query.Descend(key).Constrain(parameters[key]);
			}

			IObjectSet os = query.Execute();
			if (!os.HasNext())
				return null;

			ArrayList list = new ArrayList();
			while (os.HasNext())
				list.Add(os.Next());

			return (object[])list.ToArray(typeof(object));
		}

        /// <summary>
        /// Retrieves the objects with the provided query.
        /// </summary>
        /// <param name="query">The query to execute when retrieving the objects.</param>
        /// <returns>An array of the retrieved objects.</returns>
        static public object[] GetObjects(IQuery query)
		{
			IObjectSet os = query.Execute();
			if (!os.HasNext())
				return null;

			ArrayList list = new ArrayList();
			while (os.HasNext())
				list.Add(os.Next());

			return (object[])list.ToArray(typeof(object));
		}*/

        /// <summary>
        /// Retrieves a single object of the specified type with data matching the provided parameter.
        /// </summary>
        /// <param name="type">The type of object to retrieve.</param>
        /// <param name="parameterName">The name of the parameter to match.</param>
        /// <param name="parameterValue">The value of the parameter to match.</param>
        /// <returns>The object of the specified type with data matching the parameter.</returns>
        static public object GetObject(Type type, string parameterName, object parameterValue)
        {
            IObjectContainer dataStore = GetDataStore(type, true);

            try
            {
                return GetObject(dataStore, type, parameterName, parameterValue);
            }
            catch (Exception ex)
            {
                throw ex;

                return null;
            }
        }

        /// <summary>
        /// Retrieves a single object of the specified type with data matching the provided parameter.
        /// </summary>
        /// <param name="dataStore">The data store to get the object from.</param>
        /// <param name="type">The type of object to retrieve.</param>
        /// <param name="parameterName">The name of the parameter to match.</param>
        /// <param name="parameterValue">The value of the parameter to match.</param>
        /// <returns>The object of the specified type with data matching the parameter.</returns>
        static public object GetObject(IObjectContainer dataStore, Type type, string parameterName, object parameterValue)
		{
            IQuery query = dataStore.Query();
			query.Constrain(type);
            query.Descend(parameterName).Constrain(parameterValue);

			IObjectSet os = query.Execute();
			if (os.HasNext())
				return os.Next();
			else
				return null;
		}

        /*/// <summary>
        /// Retrieves a single object of the specified type with data matching the provided parameters.
        /// </summary>
        /// <param name="type">The type of object to retrieve.</param>
        /// <param name="parameters">The parameters to match to the data on the object.</param>
        /// <returns>The object of the specified type with data matching the parameters.</returns>
        static public object GetObject(string dataStoreName, Type type, Hashtable parameters)
		{
			IQuery query = GetDataStore(type, true).Query();
			query.Constrain(type);
			foreach (string key in parameters.Keys)
			{
				query.Descend(key).Constrain(parameters[key]);
			}

			IObjectSet os = query.Execute();
			if (os.HasNext())
				return os.Next();
			else
				return null;
		}*/

        /// <summary>
        /// Retrieves a single object by executing the provided query.
        /// </summary>
        /// <param name="objectSet">The IObjectSet to get the object from.</param>
        /// <returns>The object retrieved from the IObjectSet.</returns>
        static public object GetObject(IObjectSet objectSet)
		{
            if (objectSet.HasNext())
                return objectSet.Next();
			else
				return null;
		}

        /*/// <summary>
        /// Retrieves a single object by executing the provided delegate.
        /// </summary>
        /// <param name="dlgt">The delegate to execute.</param>
        /// <returns>The object retrieved when executing the delegate.</returns>
        static public Collection<obj> Get<obj>(Predicate dlgt)
        {
            return db.Query<obj>(dlgt);
        }*/

        /// <summary>
        /// Creates a query constrained to the specified type into the data store that corresponds with the specified type.
        /// </summary>
        /// <param name="type">The type to base the query on and constrain it to.</param>
        /// <returns>A query constrained to the provided type into the corresponding data store.</returns>
        static public IQuery Query(Type type)
        {
            IObjectContainer dataStore = GetDataStore(type, true);

            return Query(dataStore, type);
        }

        /// <summary>
        /// Creates a query constrained to the specified type into the data store that corresponds with the specified type.
        /// </summary>
        /// <param name="store">The data store to create the query for.</param>
        /// <param name="type">The type to base the query on and constrain it to.</param>
        /// <returns>A query constrained to the provided type into the corresponding data store.</returns>
        static public IQuery Query(IObjectContainer store, Type type)
        {
            IQuery query = store.Query();
            query.Constrain(type);
            return query;
        }

        /// <summary>
        /// Searches objects of the specified type to match any of the specified properties with the provided query.
        /// </summary>
        /// <param name="dataStore">The data store to search in.</param>
        /// <param name="type">The type of object to search.</param>
        /// <param name="properties">An array of field names to search.</param>
        /// <param name="query">The query to look for in one of the specified field names.</param>
        /// <returns>An array of the matching objects.</returns>
        static public object[] SearchObjects(Type type, string[] fields, string query)
		{
            IObjectContainer dataStore = GetDataStore(type, true);

			ArrayList list = new ArrayList();

			foreach (string field in fields)
			{
				object[] objects = GetObjects(type, field, query);
				if (objects != null)
				{
					foreach (object obj in objects)
					{
						if (!list.Contains(obj))
							list.Add(obj);
					}
				}
			}

			return list.ToArray();
		}

        /// <summary>
        /// Saves the provided object.
        /// </summary>
        /// <param name="entity">The object to save.</param>
         static public void Save(Entity entity)
        {
            // Get the data store of the entity
            IObjectContainer dataStore = GetDataStore(entity.GetType(), true);

            try
            {
                Save(dataStore, entity, true);
            }
            catch (Exception ex)
            {
                dataStore.Close();

                // TODO: Add error logging
                throw ex;
            }
        }
		
        /// <summary>
        /// Saves the provided object.
        /// </summary>
        /// <param name="dataStore">The data store to save to.</param>
        /// <param name="entity">The object to save.</param>
        /// <param name="commit">A flag indicating whether to commit the data store after saving.</param>
        static public void Save(IObjectContainer dataStore, Entity entity, bool commit)
		{
            ArrayList toSave = new ArrayList();

            if (entity != null)
            {
                // Loop through all the properties on the entity class
                foreach (PropertyInfo property in entity.GetType().GetProperties())
                {
                    // Get the custom attributes
                    object[] attributes = (object[])property.GetCustomAttributes(true);

                    // Loop through all the attributes
                    foreach (object attribute in attributes)
                    {
                        if (attribute is BaseEntityReferenceAttribute)
                        {
                            BaseEntityReferenceAttribute reference = (BaseEntityReferenceAttribute)attribute;

                            // Get the referenced entities from the property
                            object referenceValue = property.GetValue(entity, null);

                            if (referenceValue != null && reference.IDsPropertyName != null && reference.IDsPropertyName != String.Empty)
                            {
                                PropertyInfo idsProperty = entity.GetType().GetProperty(reference.IDsPropertyName);

                                if (referenceValue is Entity)
                                {
                                    idsProperty.SetValue(entity, ((Entity)referenceValue).ID, null);
                                }
                                else
                                {
                                    idsProperty.SetValue(entity, Collection<Entity>.GetIDs((Entity[])referenceValue), null);
                                }
                            }

                            if (!reference.ExcludeFromDataStore)
                            {
                                // Check if the save is to cascade
                                if (reference.CascadeSave)
                                {
                                    if (referenceValue is Entity)
                                    {
                                        // Update the value of the mirror property
                                        UpdateMirrors(entity, (Entity)referenceValue, reference);

                                        // Save the referenced entity
                                        // TODO: Check if this is done properly
                                        toSave.Add((Entity)referenceValue);
                                        //Save(dataStore, (Entity)referenceValue, false);
                                    }
                                    else
                                    {
                                        // Save the reference entities
                                        foreach (Entity referencedEntity in (Entity[])referenceValue)
                                        {
                                            // Update the value of the mirror property
                                            UpdateMirrors(entity, referencedEntity, reference);

                                            // TODO: Check if this is done properly
                                            toSave.Add((Entity)referencedEntity);
                                            //Save(dataStore, referencedEntity, false);
                                        }
                                    }
                                }
                                else
                                {
                                    if (referenceValue is Entity)
                                    {
                                        Entity referencedEntity = (Entity)referenceValue;
                                        
                                        // Check if the value needs to be rebound
                                        if (!dataStore.Ext().IsStored(referencedEntity))
                                        {
                                            IQuery referenceQuery = dataStore.Query();
                                            referenceQuery.Constrain(referencedEntity.GetType());
                                            referenceQuery.Descend("id").Constrain(referencedEntity.ID);

                                            IObjectSet referenceSet = referenceQuery.Execute();

                                            // Load the original entity and delete the referenced entities
                                            if (referenceSet.HasNext())
                                                referencedEntity = (Entity)referenceSet.Next();

                                            // Set a bound copy of the referenced object to the property to ensure it won't get duplicated
                                            property.SetValue(entity, referencedEntity, null);
                                        }
                                    }
                                    else
                                    {

                                        ArrayList originalReferences = new ArrayList();

                                        Guid[] originalReferenceIDs = Collection<Entity>.GetIDs((Entity[])referenceValue);

                                        foreach (Guid originalReferenceID in originalReferenceIDs)
                                        {
                                            Entity originalReference = (Entity)GetObject(typeof(Entity), "id", originalReferenceID);

                                            UpdateMirrors(entity, originalReference, reference);

                                            originalReferences.Add(originalReference);
                                        }

                                        
                                        if (originalReferences.Count > 0)
                                            property.SetValue(entity, originalReferences.ToArray(originalReferences[0].GetType()), null);
                                        else
                                            property.SetValue(entity, null, null);

                                    }
                                }
                            }
                            else
                            {
                                // Clear the property because it's excluded
                                property.SetValue(entity, null, null);
                            }
                        }
                    }
                }

                // Pack up the object
                /*Collection<Entity> unhandled = Pack(entity);

                // Save the entity
                dataStore.Set(entity);

                // Save the sub-entities that weren't saved automatically
                if (unhandled != null)
                {
                    foreach (Entity sub in unhandled)
                        Save(sub);
                }*/

                // Save the entity
                dataStore.Store(entity);

                foreach (object obj in toSave)
                {
                    if (obj is Entity)
                        Save(dataStore, (Entity)obj, false);
                }

                if (commit)
                {
                    dataStore.Commit();
                }
            }
		}
       
        /// <summary>
        /// Updates the provided object.
        /// </summary>
        /// <param name="entity">The entity to update.</param>
        static public void Update(Entity entity)
        {
            IObjectContainer dataStore = GetDataStore(entity.GetType(), true);
       
            Entity originalEntity = GetOriginal(dataStore, entity.GetType(), true, entity.ID);

       
            try
            {
                Update(dataStore, entity, originalEntity, true);
            }
            catch (Exception ex)
            {

                CloseDataStore(dataStore);

                // TODO: Add error reporting
                throw ex;
            }
        }

        /// <summary>
        /// Updates the provided object.
        /// </summary>
        /// <param name="dataStore">The data store to update the object in.</param>
        /// <param name="entity">The entity to update.</param>
        static public void Update(IObjectContainer dataStore, Entity entity)
        {
            Entity originalEntity = GetOriginal(dataStore, entity.GetType(), true, entity.ID);

            Update(dataStore, entity, originalEntity, true);
        }

        /// <summary>
        /// Updates the provided object.
        /// </summary>
        /// <param name="dataStore">The data store to update the object in.</param>
        /// <param name="entity">The entity to update.</param>
        /// <param name="commit">A flag indicating whether to commit the data store.</param>
        static public void Update(IObjectContainer dataStore, Entity entity, Entity originalEntity, bool commit)
		{
            System.Diagnostics.Trace.WriteLine(entity.GetType() + ": " + entity.ToString(), "Db4oHelper.Update");
         
            // TODO: Check if this is needed. It shouldnt be
            // Get a bound version of the provided entity from the DB
            /*Entity boundEntity;
            if (dataStore.Ext().IsStored(entity))
                boundEntity = entity;
            else
                boundEntity = (Entity)GetObject(entity.GetType(), "id", entity.ID);*/

            // Loop through all the properties on the entity class
            foreach (PropertyInfo property in entity.GetType().GetProperties())
            {
                // Get the custom attributes
                object[] attributes = (object[])property.GetCustomAttributes(true);

                // Loop through all the attributes
                foreach (object attribute in attributes)
                {
                    if (attribute is BaseEntityReferenceAttribute)
                    {
                        BaseEntityReferenceAttribute reference = (BaseEntityReferenceAttribute)attribute;

                        if (!reference.ExcludeFromDataStore)
                        {
                            // Get the referenced entities from the property
                            object referenceValue = property.GetValue(entity, null);

                            // Check if the save is to cascade
                            if (reference.CascadeUpdate)
                            {
                                if (referenceValue is Entity)
                                {
                                    Entity referencedEntity = (Entity)referenceValue;

                                    // Delete the original referenced entity
                                    Delete(dataStore, (Entity)GetObject(referencedEntity.GetType(), "id", referencedEntity.ID), false);

                                    UpdateMirrors(entity, referencedEntity, reference);

                                    // Save the new referenced entity
                                    Save(dataStore, (Entity)referenceValue, false);
                                }
                                else
                                {
                                    // Save the reference entities
                                    foreach (Entity referencedEntity in (Entity[])referenceValue)
                                    {
                                        // Delete the original referenced entity
                                        Delete(dataStore, (Entity)GetObject(referencedEntity.GetType(), "id", referencedEntity.ID), false);

                                        UpdateMirrors(entity, referencedEntity, reference);

                                        // Save the new referenced entity
                                        Save(dataStore, (Entity)referencedEntity, false);
                                    }
                                }
                            }
                            else
                            {
                                if (referenceValue is Entity)
                                {
                                    UpdateMirrors(entity, (Entity)referenceValue, reference);

                                    // Set a bound copy of the referenced object to the property to ensure it won't get duplicated
                                    property.SetValue(entity, GetObject(property.PropertyType, "id", ((Entity)referenceValue).ID), null);
                                }
                                else
                                {
                                    //if (originalEntity != null)
                                    //{
                                    //  PropertyInfo originalProperty = originalEntity.GetType().GetProperty(property.Name);

                                    //  Entity[] originalReferences = (Entity[])originalProperty.GetValue(originalEntity, null);

                                    Entity[] newReferences = (Entity[])property.GetValue(entity, null);

                                    Entity[] originalReferences = (Entity[])property.GetValue(originalEntity, null);

                                    // TODO: Check if original references need to be loaded from the original entity itself
                                    // Get the original references from the original entity
                                    /*List<Entity> originalReferences = new List<Entity>();
                                    if (newReferences != null)
                                    {
                                        foreach (Entity newReference in newReferences)
                                        {
                                            IQuery newReferenceQuery = dataStore.Query();
                                            newReferenceQuery.Constrain(newReference.GetType());
                                            newReferenceQuery.Descend("id").Constrain(newReference.ID);
                                            IObjectSet newReferenceSet = newReferenceQuery.Execute();
                                            if (newReferenceSet.HasNext())
                                                originalReferences.Add((Entity)newReferenceSet.Next());
                                        }
                                    }*/

                                    ArrayList references = new ArrayList();

                                    // If a reference exists in both old and new copy then keep it in the new
                                    if (originalReferences != null)
                                    {
                                        for (int i = 0; i < originalReferences.Length; i++)
                                        {
                                            UpdateMirrors(entity, originalReferences[i], reference);

                                            if (Array.IndexOf(Collection<Entity>.GetIDs(newReferences), originalReferences[i].ID) > -1)
                                            {
                                                references.Add(originalReferences[i]);
                                            }
                                        }
                                    }

                                    // Set a bound copy of the referenced object to the property to ensure it won't get duplicated
                                    if (references != null && references.Count > 0)
                                        property.SetValue(entity, references.ToArray(originalReferences[0].GetType()), null);
                                    else
                                        property.SetValue(entity, null, null);
                                    // }
                                }
                            }
                        }
                        else
                        {
                            // Clear the property because it's excluded
                            property.SetValue(entity, null, null);
                        }
                    }
                }
            }

            dataStore.Store(entity);

            if (commit)
                dataStore.Commit();
		}

        /// <summary>
        /// Updates all entities in the array provided.
        /// </summary>
        /// <param name="entities">The entities to update.</param>
        static void Update(Entity[] entities)
        {
            if (entities != null)
                foreach (Entity entity in entities)
                    Update(entity);
        }

        /// <summary>
        /// Deletes the provided object.
        /// </summary>
        /// <param name="entity">The object to delete.</param>
        static public void Delete(Entity entity)
		{
            IObjectContainer dataStore = GetDataStore(entity.GetType(), true);

            try
            {
                Delete(dataStore, entity, true);
            }
            catch (Exception ex)
            {
                dataStore.Close();

                // TODO: Add error reporting
                throw ex;
            }
        }

        /// <summary>
        /// Deletes the provided object.
        /// </summary>
        /// <param name="dataStore">The data store to delete the entity from.</param>
        /// <param name="entity">The object to delete.</param>
        /// <param name="commit">A flag indicating whether to commit the data store.</param>
        static public void Delete(IObjectContainer dataStore, Entity entity, bool commit)
        {
            if (entity != null)
            {
                // Make sure that the provided entity is bound to the DB
                if (entity != null && entity.ID != Guid.Empty && !dataStore.Ext().IsStored(entity))
                    entity = (Entity)GetObject(typeof(object), "id", entity.ID);

                // Loop through all the properties on the entity class
                foreach (PropertyInfo property in entity.GetType().GetProperties())
                {
                    // Get the custom attributes
                    object[] attributes = (object[])property.GetCustomAttributes(true);

                    // Loop through all the attributes
                    foreach (object attribute in attributes)
                    {
                        if (attribute is BaseEntityReferenceAttribute)
                        {
                            BaseEntityReferenceAttribute reference = (BaseEntityReferenceAttribute)attribute;

                            // Check if the deletion is to cascade
                            if (reference.CascadeDelete)
                            {
                                // Get the referenced entities from the property
                                object referenceValue = property.GetValue(entity, null);

                                if (referenceValue is Entity)
                                {
                                    // Delete the referenced entity
                                    Delete(dataStore, (Entity)referenceValue, false);
                                }
                                else
                                {
                                    // Delete the reference entities
                                    foreach (Entity referencedEntity in (Entity[])referenceValue)
                                        Delete(dataStore, referencedEntity, false);
                                }
                            }
                        }
                    }
                }

                // Get the sub-entities
                /*Collection<Entity> subEntities = entity.Pack();

                // Delete the entity
                dataStore.Delete(entity);

                // Delete the sub-entities
                if (subEntities != null)
                {
                    // Loop through the sub-entities and delete them
                    foreach (Entity sub in subEntities)
                        dataStore.Delete(sub);
                }*/

                dataStore.Delete(entity);

                if (commit)
                    dataStore.Commit();
            }
		}
		#endregion

        #region Utility functions
        static public void TransferData(Entity source, Entity destination)
        {
            if (source == null)
                throw new ArgumentNullException("source");

            if (destination == null)
                throw new ArgumentNullException("destination");

            // Loop through all the properties to transfer the data
            foreach (PropertyInfo property in source.GetType().GetProperties())
            {
                bool ignore = false;

                // Check the attributes to make sure the property isn't marked to be ignored
                object[] attribs = property.GetCustomAttributes(true);
                foreach (object attrib in attribs)
                {
                    if (attrib is BaseEntityReferenceAttribute && ((BaseEntityReferenceAttribute)attrib).ExcludeFromDataStore)
                        ignore = true;
                }

                PropertyInfo destinationProperty = destination.GetType().GetProperty(property.Name);

                object value = property.GetValue(source, (object[])null);
                object value2 = destinationProperty.GetValue(destination, (object[])null);

                if (destinationProperty.CanWrite && !ignore)
                {
                    if (value != null && !value.Equals(value2))
                        destinationProperty.SetValue(destination, value, (object[])null);
                }
            }
        }

        /// <summary>
        /// Calls the Pack() function on the object if it's an Entity.
        /// </summary>
        /// <param name="entity">The entity to pack.</param>
        /// <returns>A collection of entities that need to be handled manually (that weren't handled by the Pack function).</returns>
        static public Collection<Entity> Pack(Entity entity)
        {
            return entity.Pack();
        }
        
        /// <summary>
        /// Retrieves the type as specified by the provided string.
        /// </summary>
        /// <param name="type">The fully qualified name of the type to retrieve.</param>
        /// <returns>The type specified by the provided string.</returns>
        static public Type GetType(string type)
        {
            if (type.IndexOf(".Modules.") > -1)
            {
                string[] parts = type.Split('.');
                string ns = String.Empty;
                // Get the name of the assembly containing the specified type
                for (int i = 0; i < parts.Length - 2; i++)
                {
                    ns += parts[i] + ".";
                }
                ns = ns.TrimEnd('.');
                string typeName = parts[parts.Length - 1];
                Assembly assembly = Assembly.Load(ns);
                return assembly.GetType(type, true, true);
                //return Type.GetType(typeName, true, true);
            }
            else
            {

                Assembly assembly = Assembly.GetExecutingAssembly();

                return assembly.GetType(type, true, true);
            }
        }
        #endregion

        /// <summary>
        /// Gets the names of the data stores in the data directory.
        /// </summary>
        /// <returns>The names of the data stores found.</returns>
        static public string[] GetDataStoreNames()
        {
            throw new NotImplementedException();
            // TODO: Uncommend and update
            /*List<String> names = new List<String>();

            foreach (string file in Directory.GetFiles(Config.Current.MapPath(Config.Current.DataDirectory), "*.yap"))
            {
                names.Add(Path.GetFileNameWithoutExtension(file));
            }

            return names.ToArray();*/
        }

// TODO: Remove if not needed
        /// <summary>
        /// Gets the data store that the provided entity is stored in.
        /// </summary>
        /// <param name="type">The type of entity to get the data store of.</param>
        /// <param name="throwErrorIfNotFound">A flag indicating whether an error should be thrown when no data store attribute is found.</param>
        /// <returns>The data store that the provided entity is stored in.</returns>
/*        static public IObjectContainer GetDataStore(Type type, bool throwErrorIfNotFound)
        {
            string dataStoreName = GetDataStoreName(type, throwErrorIfNotFound);
            return GetDataStore(dataStoreName);
        }*/


        /// <summary>
        /// Gets the data server that the provided entity is stored in.
        /// </summary>
        /// <param name="dataStoreName">The name of the data store to retrieve.</param>
        /// <returns>The data store that the provided entity is stored in.</returns>
        static public IObjectServer GetDataServer(string dataStoreName)
        {
            throw new NotImplementedException();
            // TODO: Uncommend and update
            /*System.Diagnostics.Trace.WriteLine(dataStoreName, "Db4oHelper.GetDataServer");

            IObjectServer server = DataAccess.Stores[dataStoreName].Server;
            if (server == null)
            {
                server = LoadDataServer(dataStoreName);
                Config.Current.AddDataServer(dataStoreName, server);
            }
            return server;*/
        }

        /// <summary>
        /// Gets the data store that the provided entity is stored in.
        /// </summary>
        /// <param name="dataStoreName">The name of the data store to retrieve.</param>
        /// <returns>The data store that the provided entity is stored in.</returns>
        static public IDataStore GetDataStore(string dataStoreName)
        {
            System.Diagnostics.Trace.WriteLine(dataStoreName, "Db4oHelper.GetDataStore");
            throw new NotImplementedException();
            // TODO: Uncomment and update
            /*
   //        IObjectServer server = Config.Current.GetDataServer(dataStoreName);
   //         if (server == null)
   //         {
   //             server = LoadDataServer(dataStoreName);
   //             Config.Current.AddDataServer(dataStoreName, server);
   //         }
            IObjectContainer store = Config.Current.GetDataStore(dataStoreName);

          //  IObjectContainer store;// = Config.Current.GetDataStore(dataStoreName);
            if (store == null)
            {
                store = LoadDataStore(dataStoreName);
            //    Config.Current.AddDataStore(dataStoreName, store);
            }
             return store;*/
        }

        /// <summary>
        /// Gets the data store that the specified entity is stored in.
        /// </summary>
        /// <param name="type">The type to load the data store for.</param>
        /// <param name="throwErrorIfNotFound">A flag indicating whether an error should be thrown when no data store attribute is found.</param>
        /// <returns>The data store that the provided entity is stored in.</returns>
        static public IObjectContainer LoadDataStore(Type type, bool throwErrorIfNotFound)
        {
            System.Diagnostics.Trace.WriteLine(type.ToString(), "Db4oHelper.LoadDataStore");

            return LoadDataStore(GetDataStoreName(type, throwErrorIfNotFound)); 
        }

        // TODO: Remove
        /*static private Db4oMessageWriter LoadLogWriter(string dataStoreName)
        {
            Db4oMessageWriter writer = new Db4oMessageWriter(dataStoreName);
            Config.Current.AddLogWriter(dataStoreName, writer);
            return writer;
        }*/

        /// <summary>
        /// Gets the data store with the specified name.
        /// </summary>
        /// <param name="dataStoreName">The name of the data store to retrieve.</param>
        /// <returns>The data store that the provided entity is stored in.</returns>
        static public IObjectContainer LoadDataStore(string dataStoreName)
        {
            throw new NotImplementedException();
            // TODO: Uncomment and update
           /*// IObjectServer server = null;
            // If the useExistingServer flag is true then use one from the application items cache
            //if (useExistingServer)
           //     server = Config.Current.GetDataServer(dataStoreName);
           // else
           //     server = LoadDataServer(dataStoreName);
            //Config.Current.GetDataServer(dataStoreName);
            IObjectContainer store = Db4oFactory.OpenFile(Config.Application.DataDirectoryPath + @"\" + dataStoreName + ".yap");

            store.Ext().Configure().MessageLevel(3);
            
            store.Ext().Configure().SetOut(System.Console.Out);
            //store.Ext().Configure().SetOut(new System.IO.StreamWriter(File.OpenWrite(Config.Current.MapPath(Config.Current.DataDirectoryPath + "/" + dataStoreName + "_output.txt"))));//.new Db4oMessageWriter());
          

            return store;*/
        }

        /// <summary>
        /// Checks whether the provided entity is stored in the corresponding data store.
        /// </summary>
        /// <param name="entity">The entity to check for.</param>
        /// <returns>A flag indicating whether the entity was found.</returns>
        static public bool IsStored(Entity entity)
        {
            IObjectContainer dataStore = GetDataStore(entity.GetType(), true);

            return dataStore.Ext().IsStored(entity);
        }


        #region Paging functions

        /// <summary>
        /// Retrieves the specified page of objects from the provided IIObjectSet.
        /// </summary>
        /// <param name="type">The type of objects being retrieved.</param>
        /// <param name="os">The IIObjectSet containing the objects.</param>
        /// <param name="pageIndex">The index of the page to retrieve.</param>
        /// <param name="pageSize">The size of each page.</param>
        /// <param name="totalObjects">The total number of objects found.</param>
        /// <returns>An array of the objects retrieved.</returns>
        static public object[] GetPage(Type type, IObjectSet os, int pageIndex, int pageSize, out int totalObjects)
        {
            int i = 0;
            os.Reset();

            ArrayList objects = new ArrayList();
            while (os.HasNext())
            {
                if ((i >= pageIndex * pageSize) && (i < (pageIndex + 1) * pageSize))
                {
                    objects.Add(os.Next());
                }
                else
                    os.Next();
                i++;
            }
            totalObjects = i;
            return (object[])objects.ToArray(type);
        }
        #endregion

        #region Sorting
        /// <summary>
        /// Applies the specified sort expression to the provided query.
        /// </summary>
        /// <param name="query">The query to apply the sort expression to.</param>
        /// <param name="sortExpression">The sort expression to apply to the query.</param>
        static public IQuery ApplySorting(IQuery query, string sortExpression)
        {
            if (query != null && sortExpression != null)
            {
                if (sortExpression.IndexOf("Descending") > -1)
                {
                    string propertyName = sortExpression.Replace("Descending", String.Empty);
                    propertyName = ToCamelCase(propertyName);
                    query.Descend(propertyName).OrderDescending();
                }
                else if (sortExpression.IndexOf("Ascending") > -1)
                {
                    string propertyName = sortExpression.Replace("Ascending", String.Empty);
                    propertyName = ToCamelCase(propertyName);
                    query.Descend(propertyName).OrderAscending();
                }
                else
                    throw new ArgumentException("The provided sort expression is invalid: " + sortExpression);
            }

            return query;
        }
        #endregion

        static public string ToCamelCase(string text)
        {
            // TODO: Check if this is done properly
            if (text == string.Empty)
                return String.Empty;

            string firstChar = text.Substring(0, 1);

            text = text.Substring(1, text.Length-1);

            text = firstChar.ToLower() + text;

            return text;
        }

        #region Sync IDs functions
        static public Entity[] SynchroniseIDs(Entity originalEntity, Entity newEntity, string associatedIDsPropertyName, Entity[] originalAssociatedEntities, Entity[] newAssociatedEntities, string idsPropertyName)
        {
            // Create a collection of entities that need to be updated
            Collection<Entity> toBeUpdated = new Collection<Entity>();

            // Get the original copy of the entity
            //Entity originalEntity = GetObject(entity.GetType(), "id", entity.ID);

            //IObjectContainer store = GetDataStore(entity.GetType(), true);
            // Load all the entities of specified type with the ID of the entity provided in the field provided
           // IQuery query = Query(associatedType);
            //query.Descend(ToCamelCase(reversePropertyName)).Constrain(entity.ID);
            
            // Get the IDs of the associated entities
            //Guid[] originalAssociatedEntityIDs = originalEntity.GetType().GetProperty(associatedIDsPropertyName).GetValue(entity, null);
            Guid[] associatedEntityIDs = (Guid[])newEntity.GetType().GetProperty(associatedIDsPropertyName).GetValue(newEntity, null);

            // Loop through all the entities that are associated with the one provided
            foreach (Entity originalAssociatedEntity in originalAssociatedEntities)
            {                
                // If the ID of the old associated entity is not found in the new IDs then remove the other association as well
                if (Array.IndexOf(associatedEntityIDs, originalAssociatedEntity.ID) == -1)
                {
                    // Get the IDs of the entities
                    PropertyInfo originalEntitiesProperty = originalAssociatedEntity.GetType().GetProperty(idsPropertyName);
                    Guid[] originalEntityIDs = (Guid[])originalEntitiesProperty.GetValue(originalAssociatedEntity, null);

                    // Remove the provided entity ID from the IDs on the specified property of the associated entity
                    ArrayList list = new ArrayList(originalEntityIDs);
                    list.Remove(newEntity.ID);
                    originalEntityIDs = (Guid[])list.ToArray(typeof(Guid));

                    // Set the updated ID array back to the property on the associated entity
                    originalEntitiesProperty.SetValue(originalAssociatedEntity, originalEntityIDs, null);

                    // Update the associated entity
                    toBeUpdated.Add(originalAssociatedEntity);
                }
            }
            
            // Loop through all the associated IDs
            foreach (Entity newAssociatedEntity in newAssociatedEntities)
            {
                // Load all the entities that are newly associated with the provided entity
                //IQuery query = Query(associatedType);
                //query.Descend("id").Constrain(associatedID.ID);

               // Entity associatedEntity = (Entity)GetObject(query.Execute());

                PropertyInfo entityIDsProperty = newAssociatedEntity.GetType().GetProperty(idsPropertyName);
                if (entityIDsProperty == null)
                    throw new ArgumentException("The specified entity IDs property '" + idsPropertyName + "' on the associated object '" + newAssociatedEntity.GetType().ToString() + "'.");
                Guid[] entityIDs = (Guid[])entityIDsProperty.GetValue(newAssociatedEntity, null);

                if (entityIDs != null)
                {
                    // If the ID of the entity is not found in the IDs of the associated entity then add ID
                    if (Array.IndexOf(entityIDs, newEntity.ID) == -1)
                    {
                        // Remove the provided entity ID from the IDs on the specified property of the associated entity
                        ArrayList list = new ArrayList(entityIDs);
                        list.Add(newEntity.ID);
                        entityIDs = (Guid[])list.ToArray(typeof(Guid));

                        // Set the updated ID array back to the property on the associated entity
                        entityIDsProperty.SetValue(newAssociatedEntity, entityIDs, null);

                        // Update the associated entity
                        toBeUpdated.Add(newAssociatedEntity);
                    }
                }
            }

            return (Entity[])toBeUpdated.ToArray(typeof(Entity));
        }

        static public void SynchroniseIDs(Entity entity, string associatedIDsProperty, Type associatedType, string idsProperty)
        {
            if (entity != null)
            {
                // TODO: Make it so associated objects that already existed and haven't changed don't need to be loaded twice (for original, and new associations)

                Entity originalEntity = (Entity)Db4oHelper.GetObject(entity.GetType(), "id", entity.ID);

                Collection<Entity> originalAssociatedEntities = new Collection<Entity>();
                if (originalEntity != null)
                {
                    foreach (Guid id in (Guid[])originalEntity.GetType().GetProperty(associatedIDsProperty).GetValue(originalEntity, null))
                    {
                        originalAssociatedEntities.Add((Entity)GetObject(associatedType, "id", id));
                        //Entity[] originalAssociatedEntities = GetGuid[] associatedEntityIDs = ;
                    }
                }

                Collection<Entity> newAssociatedEntities = new Collection<Entity>();
                foreach (Guid id in (Guid[])entity.GetType().GetProperty(associatedIDsProperty).GetValue(entity, null))
                {
                    newAssociatedEntities.Add((Entity)GetObject(associatedType, "id", id));
                    //Entity[] originalAssociatedEntities = GetGuid[] associatedEntityIDs = ;
                }

                Entity[] entities = SynchroniseIDs(
                    originalEntity,
                    entity,
                    associatedIDsProperty,
                    originalAssociatedEntities.ToArray(typeof(Entity)),
                    newAssociatedEntities.ToArray(typeof(Entity)),
                    idsProperty);

                foreach (Entity e in entities)
                    Update(e);
            }
        }
        #endregion

        static public void Activate(Entity entity, int depth)
        {
            IObjectContainer store = GetDataStore(entity.GetType(), true);
            store.Activate(entity, depth);
        }

        /// <summary>
        /// Configures the specified type and specified field to CascadeOnActivate(flag).
        /// </summary>
        /// <param name="flag">The flag indicating whether to CascadeOnActivate</param>
        /// <param name="type">The type to apply the configuration settings to.</param>
        /// <param name="fieldName">The name of the field to apply the configuration settings to.</param>
        static public void CascadeOnActivate(bool flag, Type type, string fieldName)
        {
            IObjectContainer store = GetDataStore(type, true);

            Db4oFactory.Configure().ObjectClass(type).ObjectField(fieldName).CascadeOnActivate(flag);
        }

        static public void UpdateMirrors(Entity entity, Entity referenceEntity, BaseEntityReferenceAttribute attrib)
        {
            PropertyInfo mirrorProperty = referenceEntity.GetType().GetProperty(attrib.MirrorName);

            object mirrorValue = mirrorProperty.GetValue(referenceEntity, null);


                // If the property type is NOT an array
                if (mirrorProperty.PropertyType.ToString().IndexOf("[]") == -1)
                {
                    if (mirrorValue == null || entity == null)
                    {
                        mirrorProperty.SetValue(referenceEntity, entity, null);

                    }
                    else
                    {
                        if (mirrorValue.GetType().ToString() == entity.GetType().ToString())
                        {
                            mirrorProperty.SetValue(referenceEntity, entity, null);
                        }
                        else
                            throw new InvalidOperationException("The values types are incompatible: '" + mirrorValue.GetType().ToString() + "' and '" + entity.GetType().ToString() + "'");
                    }
                }
                else
                {
                    if (mirrorValue == null)
                    {
                        ArrayList list = new ArrayList();
                        list.Add(entity);
                        mirrorProperty.SetValue(referenceEntity, list.ToArray(entity.GetType()), null);

                    }
                    else
                    {
                        if (((Entity[])mirrorValue)[0].GetType().ToString() == entity.GetType().ToString())
                        {
                            ArrayList list = new ArrayList((Entity[])mirrorValue);
                            if (!list.Contains(entity))
                                list.Add(entity);
                            mirrorProperty.SetValue(referenceEntity, list.ToArray(entity.GetType()), null);
                        }
                        else
                            throw new InvalidOperationException("The values types are incompatible: '" + mirrorValue.GetType().ToString() + "' and '" + entity.GetType().ToString() + "'");
                    }
                }

        }
        static public Entity GetOriginal(IObjectContainer store, Type type, bool throwErrorIfNotFound, Guid id)
        {
            // Load the original entity and delete the referenced entities
           // IObjectServer server = Config.Current.GetDataServer(GetDataStoreName(type, throwErrorIfNotFound));//LoadDataServer(GetDataStoreName(type, throwErrorIfNotFound));
           // IObjectContainer store = server.OpenClient();
            IQuery query = store.Query();
            query.Constrain(type);
            query.Descend("id").Constrain(id);

            IObjectSet os = query.Execute();
            Entity originalEntity = null;
            if (os.HasNext())
                originalEntity = (Entity)os.Next();
            else
                throw new InvalidOperationException("Cannot update an object that doesn't already exist in the data store.");

           // store.Close();
            return originalEntity;
        }
    }
}